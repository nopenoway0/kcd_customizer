<html>
	<head>
	<link rel="stylesheet" href="semantic/semantic.css">
		<title>KCD Customizer</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script>
			var THREE = require('three');
		</script>
		<script src="js/LoaderSupport.js"></script>
		<script src="js/OBJLoader2.js"></script>
		<script src="js/MTLLoader.js"></script>
		<script src="js/setup_functions.js"></script>
		<script src="semantic/semantic.js"></script>
		<script>
			const CONFIG_PATH = "config.json";
			let configuration = config();
			// set where to find default game models and mats, set fps, and necessary delay to achieve delay
			// and exported model directory
			const SKIN_MODEL_PATH = configuration['SKIN_MODEL_PATH'], FPS = configuration['FPS'], DELAY = 1000 / FPS, EXPORT_DIR = configuration['EXPORT_DIR'];
			const OBJ_MODEL_PATH = configuration['OBJ_MODEL_PATH'], MATERIAL_PATH = configuration['MATERIAL_PATH'];
			
			// set slide to rotate displayed model
			window.onload = () => {
				let slider = document.getElementById("rotate-head");
				slider.oninput = function() {
					current_rotation = this.value;
				};
			};

			// set up scene and rotation
			var current_rotation = 50, model = null, model_index = -1, texture_database = null;
			var scene = new THREE.Scene(), light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight - 70);
			document.body.appendChild( renderer.domElement );

			// get paths to files. model_paths and material paths must be in same order
			var model_paths = get_file_list(OBJ_MODEL_PATH, /.*\.obj/i);
			var material_paths = get_file_list(MATERIAL_PATH, /.*\.mtl/i);

			// load all textures based on materials
			create_texture_database(material_paths).then((db)=>{
				texture_database = db;
			});
			
			// start loading of first head
			next('head');

			// set up scene with lighting and camera
			scene.add( light );
			camera.position.y = .28, camera.lookAt(0,0,0), camera.position.z = 1.6, camera.rotateZ(3.14);

			// start rendering at a set delay speed
			(function startRendering(){
				setTimeout(() => {
					// if model is not null, get slider value, calculate radians of rotation
					if(model != null)
						model.setRotationFromAxisAngle(new THREE.Vector3(0,0,1), 2*3.14 * ((current_rotation - 50) / 100.0));
					renderer.render(scene, camera);
					startRendering();
				}, DELAY);
			})();

			// change models
			function set_model(new_model){
				model = new_model.detail.loaderRootNode;
			}

			function next(type){
				model_index = (model_index + 1) % model_paths.length;
				console.log('switching to ' + model_paths[model_index]);
				scene.remove(model);
				load_asset(model_paths[model_index]).then((result) =>{
					set_model(result);
					scene.add(model);
					console.log("loading following textures:" + texture_database['model'][model_index]);
					
					/**
					 * Sequentially load all textures in the corresponding index relevant to the current model. load_asset returns
					 * a promise making sure each asset is loaded sequentially. This is necessary because of the order of the meshes.
					 * Meshes in each model are broke into [0]head, [1]eyes, [2] mouth, [3]hair(optional)
					 * , [3 or 4 depending on hair] beard (optional). Thus, each texture must be loaded in order to be peroperly applied
					 * to the correct mesh.
					 */
					let p = load_asset(texture_database['model'][model_index][0], 'txt'), length = texture_database['model'][model_index].length;
					for(let x = 1; x <= length; x++){
						p = p.then((texture)=>{
							model.children[x - 1].material = new THREE.MeshLambertMaterial({map: texture}); 
							if(x < length)
								return load_asset(texture_database['model'][model_index][x], 'txt');
						});
					}
				});
			};

			function prev(type){
				if(model_index > 0)
					model_index -= 2;
				next(type);
			}

			function exportHead(){
				// create strings to show where would export
				let re = /.*\/(.*)_.*\.obj/i
				let model_name = model_paths[model_index].match(re)[1];
				let model_filepath = SKIN_MODEL_PATH + model_name + ".skin", mtl_filepath = SKIN_MODEL_PATH + model_name + ".mtl";
				rmdir(EXPORT_DIR + 'Data/custom_head')
					.then(() =>rmdir(EXPORT_DIR + 'Data/__fastload/custom_head'))
					.catch(() => mkdir(EXPORT_DIR + 'Data/custom_head'))
					.then(() => copy(model_filepath, EXPORT_DIR + 'Data/custom_head/henry.skin'))
					.then(() => copy(mtl_filepath, EXPORT_DIR + 'Data/custom_head/henry.mtl'))
					.then(()=>zipFolder(EXPORT_DIR + 'Data/custom_head/', EXPORT_DIR + 'Data/kcd_custom_head.pak', ['henry.mtl', 'henry.skin'], 'Objects/characters/humans/head'))
					.then(() => copy(EXPORT_DIR + 'Data/kcd_custom_head.pak', EXPORT_DIR + 'Data/__fastload/kcd_custom_head.pak'))
					.then(() => rmdir(EXPORT_DIR + 'Data/custom_head'));
			}

		</script>
		<div id="camera-controls" style="width:100%">
			<input style="width:100%" type="range" min="1" max="100" value="50" class="slider" id="rotate-head">
		</div>
		<div id="part-controls" style="width:100%; float: right;">
			<button class="ui icon button" onclick="prev('head')">
				<i class="angle left icon"></i>
			</button>
			Head
			<button class="ui icon button" onclick="next('head')">
				<i class="angle right icon"></i>
			</button>
			<div class = "ui primary button" onclick="exportHead()">
				Export
			</div>
		</div>
	</body>
</html>